# Obsidian Memory VPS Stack
# TLS via Let's Encrypt, OAuth routing, forward_auth for MCP

{$DOMAIN} {
    # OAuth metadata discovery (public)
    handle /auth/.well-known/oauth-authorization-server {
        reverse_proxy auth-service:3001 {
            header_up X-Forwarded-Proto {scheme}
        }
        rewrite * /.well-known/oauth-authorization-server
    }

    # OAuth endpoints (public)
    handle /auth/register {
        reverse_proxy auth-service:3001 {
            header_up X-Forwarded-Proto {scheme}
        }
        rewrite * /register
    }

    handle /auth/authorize* {
        uri strip_prefix /auth
        reverse_proxy auth-service:3001 {
            header_up X-Forwarded-Proto {scheme}
        }
    }

    handle /auth/token {
        reverse_proxy auth-service:3001 {
            header_up X-Forwarded-Proto {scheme}
        }
        rewrite * /token
    }

    # Setup endpoint for first-time passkey registration (public but rate-limited)
    handle /auth/setup* {
        uri strip_prefix /auth
        reverse_proxy auth-service:3001 {
            header_up X-Forwarded-Proto {scheme}
        }
    }

    # Protected MCP endpoint - requires valid OAuth token or API key
    handle /mcp* {
        forward_auth auth-service:3001 {
            uri /validate
            copy_headers Authorization
        }
        reverse_proxy obsidian-memory:3000 {
            # Critical: disable buffering for SSE streaming
            flush_interval -1
            header_up X-Forwarded-Proto {scheme}
        }
    }

    # WebSocket for P2P sync (sync-daemon handles its own auth)
    handle /sync {
        reverse_proxy sync-daemon:8080 {
            header_up X-Forwarded-Proto {scheme}
        }
    }

    # Root - return 404 for anything else
    handle {
        respond "Not Found" 404
    }

    # Logging
    log {
        output stdout
        format json
    }
}
